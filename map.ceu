#ifndef _MAP_CEU
#define _MAP_CEU

#include "lua.ceu"
#include "sdl.ceu"
#include "sdl-gfx.ceu"

#include "ui.ceu"
#include "colors.ceu"

input void SDL_QUIT;
input void SDL_REDRAW;
input _SDL_MouseButtonEvent* SDL_MOUSEBUTTONDOWN;

native pure _P(), _I();
native do
    int P (int p, int c, int dp, int zoom) {
        return (dp + p - c) * zoom / 100 + c;
    }
    int I (int i, int c, int dp, int zoom) {
        return (i - c) * 100 / zoom + c - dp;
    }
end

class Map with
    var int  n;   // number of countries
    var u16* cx;  // all country centers
    var u16* cy;  // all country centers

    event int       go_zoom;
    event (int,int) go_xy;
    event int       ok_clicked;
    event void      ok_changed;

    var int x = 0;
    var int y = 0;
    var int zoom = 100;
do
    _assert(_REN != null);
    _assert(_L   != null);

    _lua_getglobal(_L, "MAP");     // [ M ]
    this.n = _lua_objlen(_L,-1);
    _lua_pop(_L, 1);               // [ ]

    // cx / cy (pos n=0 unused, malloc 1 extra)
    finalize
        this.cx = _malloc((this.n+1) * sizeof(u16));
    with
        _free(this.cx);
    end
    finalize
        this.cy = _malloc((this.n+1) * sizeof(u16));
    with
        _free(this.cy);
    end

    var int xc = _REN_W / 2;
    var int yc = _REN_H / 2;

    do
        var int xmin, xmax;
            _lua_getglobal(_L, "xs_min_max");  // [ f ]
            _lua_call(_L, 0, 2);               // [ xmin | xmax ]
            xmin = _lua_tointeger(_L, -2);
            xmax = _lua_tointeger(_L, -1);
            _lua_pop(_L, 2);                   // [ ]

        var int ymin, ymax;
            _lua_getglobal(_L, "ys_min_max");  // [ f ]
            _lua_call(_L, 0, 2);               // [ ymin | ymax ]
            ymin = _lua_tointeger(_L, -2);
            ymax = _lua_tointeger(_L, -1);
            _lua_pop(_L, 2);                   // [ ]

        var int  w = xmax - xmin;
        var int  h = ymax - ymin;
        var int dx = _REN_W - w;
        var int dy = _REN_H - h;

        // best fit
        if dx < dy then
            zoom = 100*_REN_W / w;
        else
            zoom = 100*_REN_H / h;
        end

        // center on x / y
        this.x = dx/2 - xmin;
        this.y = dy/2 - ymin;
    end

    par do
        loop do
            // center
            _lua_getglobal(_L, "MAP");         // [ M ]
            loop i_, this.n do
                var int i = i_ + 1;     // C => Lua indexing
                _lua_rawgeti(_L, -1, i);           // [ M | C ]
                _lua_getfield(_L, -1, "center");   // [ M | C | pt ]
                _lua_rawgeti(_L, -1, 1);           // [ M | C | pt | x ]
                _lua_rawgeti(_L, -2, 2);           // [ M | C | pt | x | y ]
                this.cx[i] = _P(_lua_tointeger(_L,-2), xc, this.x, zoom);
                this.cy[i] = _P(_lua_tointeger(_L,-1), yc, this.y, zoom);
                _lua_pop(_L, 4);                   // [ ]
            end
            _lua_pop(_L, 1);                   // [ ]

            emit this.ok_changed;

            par/or do
                this.zoom = await go_zoom;     // ZOOM
            with
                var int x,y;
                (x,y) = await go_xy;           // PAN
                this.x = x;
                this.y = y;
            end
        end
    with
        // OK_CLICKED
        var _SDL_MouseButtonEvent* but;
        every but = SDL_MOUSEBUTTONDOWN do
            var int x = _I(but:x, xc, this.x, zoom);
            var int y = _I(but:y, yc, this.y, zoom);
            _lua_getglobal(_L, "MAP_vspoint"); // [ f ]
            _lua_pushnumber(_L, x);            // [ f | x ]
            _lua_pushnumber(_L, y);            // [ f | x | y ]
            _lua_call(_L, 2, 1);               // [ c ]
            var int c = _lua_tointeger(_L, -1);
            _lua_pop(_L, 1);                   // [ ]
            if c > 0 then
                emit this.ok_clicked => c;
            end
        end
    with
        every SDL_REDRAW do
            var int n = 1;      // traverses xs/ys continuously

            _lua_getglobal(_L, "MAP");        // [ M | T ]
            _lua_getglobal(_L, "TMAP");       // [ M | T ]
                _lua_getfield(_L, -1, "ns");  // [ M | T | ns ]
                _lua_getfield(_L, -2, "xs");  // [ M | T | ns | xs ]
                _lua_getfield(_L, -3, "ys");  // [ M | T | ns | xs | ys ]

            // for each country [0, #MAP)
            loop i_, this.n do
                var int i = i_ + 1;     // C => Lua indexing
                var u16[10] xs, ys;     // TODO: negative values?

                _lua_rawgeti(_L, -3, i);      // [ . | ns[i] ]
                var int pts = _lua_tointeger(_L, -1);
                _lua_pop(_L, 1);              // [ . ]

                // for each point [0, ns[i])
                loop j, pts do
                    _lua_rawgeti(_L, -2, n);  // [ . | xs[n] ]
                    _lua_rawgeti(_L, -2, n);  // [ . | xs[n] | ys[n] ]
                    xs[j] = _P(_lua_tointeger(_L,-2), xc, this.x, zoom);
                    ys[j] = _P(_lua_tointeger(_L,-1), yc, this.y, zoom);
                    _lua_pop(_L, 2);          // [ . ]
                    n = n + 1; // traverses xs/ys continuously
                end

                // push color
                _lua_rawgeti(_L, -5, i);        // [ . | C ]
                _lua_getfield(_L, -1, "color"); // [ . | C | clr ]
                _lua_rawgeti(_L, -1, 1);        // [ . | C | clr | r ]
                _lua_rawgeti(_L, -2, 2);        // [ . | C | clr | r | g ]
                _lua_rawgeti(_L, -3, 3);        // [ . | C | clr | r | g | b ]

                // draw country with color
                _filledPolygonRGBA(_REN, xs, ys, pts,
                    _lua_tointeger(_L, -3),
                    _lua_tointeger(_L, -2),
                    _lua_tointeger(_L, -1),
                    0xFF);

                // draw country border
                _polygonColor(_REN, xs, ys, pts, _colors.black);

                // pop color
                _lua_pop(_L, 5);                   // [ . ]

                // draw center
                //_boxColor(_REN, cx[i]-1,cy[i]-1, cx[i]+1,cy[i]+1, 
                //_colors.black);
            end

            _lua_pop(_L, 5);               // [ ]

            // for each border { {p1,p2}, {p3,p4}, ... }
/**
            _lua_getglobal(_L, "BORDERS"); // [ B ]
            loop i_, _lua_objlen(_L,1) do
                var int i = i_ + 1;     // C => Lua indexing
                _lua_rawgeti(_L, -1, i);   // [ B | t ]
                _lua_rawgeti(_L, -1, 1);   // [ B | t | p1 ]
                _lua_rawgeti(_L, -2, 2);   // [ B | t | p1 | p2 ]
                _lua_rawgeti(_L, -2, 1);   // [ B | t | p1 | p2 | x1 ]
                _lua_rawgeti(_L, -3, 2);   // [ B | t | p1 | p2 | x1 | y1 ]
                _lua_rawgeti(_L, -3, 1);   // [ B | t | p1 | p2 | x1 | y1 | x2 ]
                _lua_rawgeti(_L, -4, 2);   // [ B | t | p1 | p2 | x1 | y1 | x2 | y2 ]
                _lineRGBA(_REN,
                    _P(_lua_tointeger(_L,-4), xc, this.x, zoom),
                    _P(_lua_tointeger(_L,-3), yc, this.y, zoom),
                    _P(_lua_tointeger(_L,-2), xc, this.x, zoom),
                    _P(_lua_tointeger(_L,-1), yc, this.y, zoom),
                    0,0,0, 0xFF);
                _lua_pop(_L, 7);           // [ B ]
            end
            _lua_pop(_L, 1);               // [ ]
**/
        end
    end
end

/* MapFinger */

input _SDL_TouchFingerEvent* SDL_FINGERDOWN;
input _SDL_TouchFingerEvent* SDL_FINGERUP;
input _SDL_TouchFingerEvent* SDL_FINGERMOTION;

class MapFinger with
    var Map* map = null;
do
    _assert(this.map != null);

    loop do
        var _SDL_TouchFingerEvent* e1_ = await SDL_FINGERDOWN;
        var _SDL_TouchFingerEvent  e1 = *e1_;

        var _SDL_TouchFingerEvent* e2_;
        par/or do
            e2_ = await SDL_FINGERUP         // restart all on release of "f1"
            until e2_:fingerId == e1.fingerId;
        with
            // PAN
            par/or do
                 e2_ = await SDL_FINGERDOWN  // go to zoom when pressing "f2"
                       until e2_:fingerId != e1.fingerId;
            with
                var int x = map:x;
                var int y = map:y;
                loop do                      // stay in pan while not "f2"
                    e2_ = await SDL_FINGERMOTION
                          until e2_:fingerId == e1.fingerId;
                    emit map:go_xy => (x + (e2_:x-e1.x)*_REN_W/2,
                                       y + (e2_:y-e1.y)*_REN_H/2);
                end
            end

            // ZOOM until "f1" is released
            var _SDL_TouchFingerEvent e2 = *e2_;
            var _SDL_TouchFingerEvent* e3_;

            loop do
                var _float dx = e2.x - e1.x;
                var _float dy = e2.y - e1.y;
                var _float mA = dx * dy;

                par/or do
                    e3_ = await SDL_FINGERUP // restart zoom on release of "f2"
                          until e3_:fingerId == e2.fingerId;
                with
                    loop do                     // stay in zoom until any release
                        e3_ = await SDL_FINGERMOTION;
                        var _float mB = e3_:dx * e3_:dy;
                        if (mA > 0) and (mB < 0) or     // main diagonal
                           (mA < 0) and (mB > 0) then   // opposite diagonal
                            continue;  // unexpected zoom gesture
                        end

                        var int z;
                        if (e3_:x > e1.x) and (e3_:x > e2.x)
                        or
                           (e3_:x < e1.x) and (e3_:x < e2.x) then
                            z =  3;
                        else
                            z = -3;
                        end

                        emit map:go_zoom => map:zoom + z;
                        e2 = *e3_;
                    end
                end

                // next zoom start finger
                e3_ = await SDL_FINGERDOWN
                      until e3_:fingerId != e1.fingerId;
                e2 = *e3_;
            end
        end
    end
end

#ifdef __MAP_CEU

#include "all.ceu"

par/or do
    await SDL_QUIT;
/*** SIMUL
with
    #include "simul.ceu"
***/
with
    every SDL_REDRAW do
        _boxColor(_REN, 0,0, _REN_W,_REN_H, _colors.black);
    end
with
    do
#ifdef __ANDROID__
        _luaL_loadfile(_L,               // [ f ]
            "/data/data/org.droid_in_the_sky.global_wars/lib/lib_lua_map1.so");
#else
        _luaL_loadfile(_L, "map1.lua");  // [ f ]
#endif
        _lua_call(_L, 0, 0);             // [ ]
        var Map map;
        var MapFinger fgr with
            this.map = &map;
        end;
        await FOREVER;
    end

    _luaL_loadfile(_L, "map2.lua");  // [ f ]
    _lua_call(_L, 0, 0);             // [ ]
    var Map map;
    await 2s;

    par do
        loop i, 200 do
            await 50ms;
            if i % 2 == 0 then
                emit map.go_xy => (-1,0);
            else
                emit map.go_xy => (0,-1);
            end
        end
    with
        loop i, 200 do
            await 51ms;
            emit map.go_zoom => -1;
        end
        loop do
            await 101ms;
            emit map.go_zoom => 1;
        end
    end
with
    every SDL_REDRAW do
        _SDL_RenderPresent(_REN);
    end
end

return 0;

#endif

#endif
