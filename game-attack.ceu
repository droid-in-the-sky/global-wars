#ifndef _GAME_ATTACK_CEU
#define _GAME_ATTACK_CEU

#include "lua.ceu"
#include "sdl.ceu"
#include "sdl-gfx.ceu"

#include "ui-texture.ceu"
#include "ui-grid.ceu"
#include "map.ceu"
#include "game-state.ceu"
#include "game-move.ceu"

input void SDL_REDRAW;
input _SDL_KeyboardEvent* SDL_KEYDOWN;
input void SDL_MOUSEBUTTONDOWN;

class GameAttackOne with
    var Map& map;
    var int  me    = 0;
    var int  state = 0;
    var int  fr    = 0;

    event (bool,int) ok;
do
    _assert(this.me    != 0);
    _assert(this.state != 0);

    // await "fr" click until "me" country

    var int max;    // holds the maximum transferable armies (#t-1)
    loop do
        if this.fr == 0 then
            this.fr = await map.ok_clicked;
        end
        max = [[ STATES[@state+1][@me][@fr] - 1 ]];
        if max > 0 then
            break;          // my country, a>1:   ok!
        else
            this.fr = 0;    // not enough armies: try again!
        end
    end

    par/or do
        every SDL_REDRAW do
            _boxColor(_REN,
                     map.cx[fr]-20, map.cy[fr]-20,
                     map.cx[fr]+20, map.cy[fr]+20,
                     _colors.white);
        end
    with
        // await click at "to" country
        var int to = await map.ok_clicked;

        // same: deselect
        if this.fr == to then
            emit this.ok => (false,0);

        // other: attack/move
        else
            // check borders
            var bool border? = [[ MAP.borders[@fr][@to] ]];

            if not border? then
                emit this.ok => (false,fr);

            else
                // t <- c++
                var int a = [[ SRV_move_inc(attacks, 1, @fr, @to) ]];
                if a == max then
                    emit this.ok => (true,0);      // no more armies from "fr"
                else
                    emit this.ok => (true,fr);     // "fr" can still move
                end
            end
        end
    end
end

class GameAttack with
    var Map& map;
    var int  me  = 0;
    event void ok;
do
    _assert(_REN  != null);
    _assert(_FONT != null);
    _assert(_BGS  != null);

    _assert(this.me  != 0);

    // last "attack" state
    var int state = [[ #STATES ]];
    var char[25] type = [[ STATES[@state].type ]];
    _assert( _strcmp("attack", type) == 0 );

    // GRID "all"
    var _SDL_Rect r;        // whole screen
        r.x = _REN_W / 2;
        r.y = _REN_H / 2;
        r.w = _REN_W;
        r.h = _REN_H;

    var UIGrid g1 with
        this.ren := _REN;
        this.lay_lins = 4;
        this.lay_cols = 4;
        this.lay := _GA_g1;
        this.uis_n = 2;
        native do
            int GA_g1[16] = {
                -1, -1, -1, -1,
                -1,  0,  0, -1,     // fs
                -1,  0,  0, -1,
                -1, -1, -1,  1      // menu
            };
        end
    end;

    // AWAIT center click
    do
        // show current state
        var GameState st with
            this.map = map;
            this.idx = state;    // start from last
        end;

        // text texture
        var _char[20] str;
        _sprintf(str, "%s", "Move & Attack");
        var _SDL_Texture* tex;
            finalize
                tex = _SDL_text2texture(_REN, _FONT, str,
                                        &_colors.black, _BGS[this.me]);

            with
                _SDL_DestroyTexture(tex);
            end
        var UITexture ui_fs with
            this.ren := _REN;
            this.tex := tex;
            this.bg_clr := _BGS[me];
        end;

        spawn UIGridItem in g1.uis with
            this.idx = 0;
            this.ui  = &ui_fs;
        end;
        //[1] = null;       // menu
        call/rec g1.go(&r);

        await 2s;
        //await SDL_MOUSEBUTTONDOWN;
    end

    // GRID "menu"
    var UIGrid g2 with
        this.ren := _REN;
        this.lay_lins = 2;
        this.lay_cols = 3;
        this.lay := _GA_g2;
        this.uis_n = 2;
        native do
            int GA_g2[] = {
                -1, -1, -1,
                -1,  0,  1  // ok
            };
        end
    end;

    // ui_ok
    var UITexture ui_ok with
        this.ren := _REN;
        this.tex := _TEX_OK;
    end;

    spawn UIGridItem in g1.uis with
        this.idx = 1;
        this.ui  = &g2;
    end;

    spawn UIGridItem in g2.uis with
        this.idx = 1;
        this.ui  = &ui_ok;
        //g2.uis[0] = null;   // no
    end;
    call/rec g1.go(null);

    finalize with
        [[ attacks = nil ]];
    end

    // loop until all "atts" are chosen
    //  - restart on "no"   (only after 1st att)
    //  - quit    on "ok"

    par/or do
        // button "OK": quit
        await ui_ok.ok_clicked;
    with
        loop do
            // emitted whenever "atts" changes to show "X"
            event void e;

            par/or do
                // button "NO": restart
                await e;
                var UITexture ui with
                    this.ren := _REN;
                    this.tex := _TEX_NO;
                end;
                spawn UIGridItem in g2.uis with
                    this.idx = 0;
                    this.ui  = &ui;
                end;
                call/rec g1.go(null);
                await ui.ok_clicked;
            with

                // restart attacks table
                [[ attacks = {} ]];

                // one loop foreach "attack"
                var int fr = 0;               // initially, no one is selected
                loop do
                    // new temporary state "attacking"
                    //      SRV_move_ins(armies)
                    [[ SRV_move_ins(@this.me, attacks) ]];
                    finalize with
                        [[ SRV_move_rem() ]];
                    end

                    // show next state
                    var GameState st with
                        this.map = map;
                        this.idx = state+1;     // tmp state
                    end;

                    // show next move
                    var GameMove mv with
                        this.map = map;
                        this.idx = (state+1)/2; // tmp move
                    end;

                    var GameAttackOne one with
                        this.map   = map;
                        this.me    = me;
                        this.state = state;
                        this.fr    = fr;
                    end;

                    var bool any?;
                    (any?, fr) = await one.ok; // keep "fr" as selected
                    if any? then
                        emit e;     // show "X" if any army was moved
                    end
                end
            end
        end
    end

    // new state "fortifying"
    [[ SRV_move(@this.me, attacks) ]];

    emit this.ok;
end

#ifdef __GAME_ATTACK_CEU

#include "all.ceu"

par/or do
    await SDL_QUIT;
/*** SIMUL
with
    @include(simul.ceu)
***/
with
    every SDL_REDRAW do
        _boxRGBA(_REN, 0,0, _REN_W,_REN_H, 0,0,0, 0xFF);
    end
with
    loop do
        do
            [[ dofile 'g4.lua' ]];

            var Map map;

            var GameAttack att with
                this.map = map;
                this.me  = 1;
            end;

            await att.ok;
        end
    end
with
    every SDL_REDRAW do
        _SDL_RenderPresent(_REN);
    end
end

escape 0;

#endif
#endif
