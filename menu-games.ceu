#ifndef _MENU_GAMES_CEU
#define _MENU_GAMES_CEU

#include "lua.ceu"
#include "sdl.ceu"
#include "sdl-gfx.ceu"

#include "sdl-colors.ceu"
#include "ui.ceu"
#include "ui-scroll.ceu"
#include "ui-grid.ceu"
#include "ui-texture.ceu"

input void SDL_REDRAW;

interface MenuGamesListener with
    event int ok_rm;
    event int ok_go;
end

class MenuGamesOne with
    var char* file = null;
    var UI&   ui;
    var int   n    = 0;

    var MenuGamesListener& lst;
do
    _assert(_REN != null);
    _assert(_TEX_RM != null);
    _assert(_TEX_OK != null);

    _assert(this.n    != 0);
    _assert(this.file != null);
    [[ dofile(@this.file) ]];

    // n players
    var int ps = 0;
    loop p in 6 do
        var bool exists? = [[ PLAYERS[@p+1] ~= false ]];
        if exists? then
            ps = ps + 1;
        end
    end

    var int state_n = [[ #STATES ]];
    var char[20] state_type = [[ STATES[@state_n].type ]];

    var UIGrid grid with
        this.ren := _REN;
        this.lay_lins = 4;
        this.lay_cols = 6;
        this.lay := __MENU_GAMES_CEU_grid;
        this.uis_n = 9;
        native do
            int _MENU_GAMES_CEU_grid[] = {
                 0,  0,  1,  1,  2,  2,     // ps
                 0,  0,  3,  3,  4,  4,     // state_n
                 0,  0,  5,  5,  6,  6,     // state_type
                 0,  0, -1, -1,  7,  8      // del, go
            };
        end

        this.spc_x  = 10;
        this.spc_y  = 10;
        this.clr_cell_bg := &_colors.gray;
    end;

    // PS
        var _SDL_Texture* tex1;
            finalize
                tex1 = _SDL_text2texture(_REN, _FONT, "Players",
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex1);
            end
        var UITexture ui1 with
            this.ren := _REN;
            this.tex := tex1;
        end;
    //
        var _char[5] str2;
        _sprintf(str2, "%d", ps);
        var _SDL_Texture* tex2;
            finalize
                tex2 = _SDL_text2texture(_REN, _FONT, str2,
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex2);
            end
        var UITexture ui2 with
            this.ren := _REN;
            this.tex := tex2;
        end;

    // STATE_N
        var _SDL_Texture* tex3;
            finalize
                tex3 = _SDL_text2texture(_REN, _FONT, "Week",
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex3);
            end
        var UITexture ui3 with
            this.ren := _REN;
            this.tex := tex3;
        end;
    //
        var _char[5] str4;
        _sprintf(str4, "%d", state_n);
        var _SDL_Texture* tex4;
            finalize
                tex4 = _SDL_text2texture(_REN, _FONT, str4,
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex4);
            end
        var UITexture ui4 with
            this.ren := _REN;
            this.tex := tex4;
        end;

    // STATE_TYPE
        var _SDL_Texture* tex5;
            finalize
                tex5 = _SDL_text2texture(_REN, _FONT, "Action",
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex5);
            end
        var UITexture ui5 with
            this.ren := _REN;
            this.tex := tex5;
        end;
    //
        var _SDL_Texture* tex6;
            finalize
                tex6 = _SDL_text2texture(_REN, _FONT, state_type,
                                        &_colors.black, null);
            with
                _SDL_DestroyTexture(tex6);
            end
        var UITexture ui6 with
            this.ren := _REN;
            this.tex := tex6;
        end;

    // RM
        var UITexture ui7 with
            this.ren := _REN;
            this.tex := _TEX_RM;
            this.align_x = _UI_ALIGN_LEFT;
        end;
    // OK
        var UITexture ui8 with
            this.ren := _REN;
            this.tex := _TEX_OK;
            this.align_x = _UI_ALIGN_LEFT;
        end;
    // TODO: OK <=> HOURGLASS

    this.ui = grid;
    spawn UIGridItem in grid.uis with
        this.idx = 1;
        this.ui = &ui1;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 2;
        this.ui = &ui2;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 3;
        this.ui = &ui3;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 4;
        this.ui = &ui4;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 5;
        this.ui = &ui5;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 6;
        this.ui = &ui6;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 7;
        this.ui = &ui7;
    end;
    spawn UIGridItem in grid.uis with
        this.idx = 8;
        this.ui = &ui8;
    end;

    par/or do
        await ui7.ok_clicked;
        emit this.lst.ok_rm => this.n;
    with
        await ui8.ok_clicked;
        emit this.lst.ok_go => this.n;
    end
end

class MenuGames with
    interface MenuGamesListener;
do
    _assert(_REN != null);

    loop do
        var int n = [[ #GAMES ]];
        if n == 0 then
            break;
        end

        // GRID [ g1 | g2 | ... ]

        var int n_ = n;
        if n_ % 2 == 1 then
            n_ = n_ + 1;        // fill to even number
        end
        var int* lay;
            finalize
                lay = _malloc(n_ * sizeof(int));
            with
                _free(lay);
            end
        loop i in n_ do
            lay[i] = i;
        end

        var UIGrid grid1 with
            this.ren := _REN;
            this.lay_lins = n_/2;
            this.lay_cols = 2;
            this.lay := lay; // { 0, 1, ..., n-1 }
            this.uis_n = n_;

            this.rect.w = 5*_REN_W / 6 - 5;     // -5 avoids x-scroll
            this.rect.h = n_*_REN_H / 6;
        end;

        // GAMES: g1, g2, ...

        pool MenuGamesOne[] ones;
        loop i in n do
            var MenuGamesOne* one = new MenuGamesOne in ones with
                var char[25] file = [[ GAMES[@i+1] ]];
                this.file = file;
                            // not held
                this.n    = i + 1;
                this.lst  = outer;
            end;
            spawn UIGridItem in grid1.uis with
                this.idx = i;
                this.ui = &one:ui;
            end;
        end

        // SCROLL [ g1 | g2 | ... ]

        var UIScroll scroll with
            this.ren := _REN;
            this.ui  = grid1;
            this.clr_scroll := &_colors.white;
                            // global
        end;

        // NEW

        var UITexture ui_new with
            this.ren := _REN;
            this.tex := _TEX_OK;
        end;

        // GRID  [ scroll | new ]

        var UIGrid grid2 with
            this.ren := _REN;
            this.lay_lins = 1;
            this.lay_cols = 6;
            this.uis_n = 2;
            this.lay := _MENUGAMES_lay2;
            native do
                int MENUGAMES_lay2[] = { 0,0,0,0,0,1 };
            end
        end;
        spawn UIGridItem in grid2.uis with
            this.idx = 0;
            this.ui  = &scroll;
        end;
        spawn UIGridItem in grid2.uis with
            this.idx = 1;
            this.ui  = &ui_new;
        end;

        var _SDL_Rect r;        // whole screen
            r.x = _REN_W / 2;
            r.y = _REN_H / 2;
            r.w = _REN_W;
            r.h = _REN_H;
        call/rec grid2.go(&r);

        // AWAIT RM or NEW

        par/or do
            await ui_new.ok_clicked;
            emit this.ok_go => 0;       // new game
        with
            var int rm = await this.ok_rm;

            [[
                os.remove(GAMES[@rm])
                table.remove(GAMES, @rm)
                local f = assert(io.open('main.lua', 'w'))
                f:write('GAMES = '..table2string(GAMES)..'\n')
                f:close()
            ]];
        end
    end
end

#ifdef __MENU_GAMES_CEU

input void SDL_QUIT;

#include "all.ceu"

class MenuGamesListenerImpl with
    interface MenuGamesListener;
do
end

par/or do
    await SDL_QUIT;
/*** SIMUL
with
    @include(simul.ceu)
***/
with
    every SDL_REDRAW do
        _boxRGBA(_REN, 0,0, _REN_W,_REN_H, 0,0,0, 0xFF);
    end
with
    var _SDL_Rect r;        // whole screen
        r.x = _REN_W / 2;
        r.y = _REN_H / 2;
        r.w = _REN_W;
        r.h = _REN_H;

    do
        var MenuGamesListenerImpl lst;
        var MenuGamesOne one with
            this.file := "g1.lua";
            this.n    = 1;
            this.lst  = lst;
        end;
        call/rec one.ui.go(&r);
        par/or do
            var int n = await lst.ok_rm;
            _printf("RM: %d\n", n);
        with
            var int n = await lst.ok_go;
            _printf("GO: %d\n", n);
        end
    end

    var MenuGames menu;
    var int n = await menu.ok_go;
    _printf("GO: %d\n", n);
with
    every SDL_REDRAW do
        _SDL_RenderPresent(_REN);
    end
end

escape 0;

#endif
#endif
